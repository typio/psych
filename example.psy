number := 42
PI : f32 : 3.14

string := "Hello"
letter_a : char : 'A'

arr := [1, 2, 3]
arr2d : [2, 3]i32 = [ 1, 2, 3,
                      4, 5, 6 ]

numbers_house : &i32 : &number
numbers_house.* = 43

add :: (a: i32, b: i32) -> i32 {
  return a + b
}

reduce :: (arr: []T, f: (T, T) -> T, init: T) -> T {
  if arr |> len > 0 {
    return f(reduce(arr[..<-1], f, init), arr[-1])
  } else {
    return init
  }
}

// Will compile error if called on types without "+" operator
sum :: (arr: []T) -> T {
  return reduce(arr, add, 0)
}

map_inplace :: (arr: []T, f: T -> T) -> {
  for &e in arr {
    e.* = f(e.*)
  }
}

map :: (arr: [N]T, f: T -> T) -> [N]T {
  result : [N]
  for e, i in arr {
    result.i = f(e.*)
  }
  return result
}

magnify :: (arr: []T, multiplier: T2) -> []T3 {
  // Implicit comptime type if unspecified in function param, perhaps
  return arr |> map(m -> m * multiplier)
}
